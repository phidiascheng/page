<html>
  <head>
    <meta charset="utf-8" />
    <script src="js/hanzi-writer.min.js"></script>
    <script src="js/pdf-lib.min.js"></script>
  </head>
  <body>
    <div style="display: flex; justify-content: center; width: 100%; ">
        <div style="width: 50%;">
            <div>
              <label for="text-input">输入汉字 最多12个汉字</label><br><br>
              <input style="width:100%;" id="text-input" type="text" placeholder="汉字:">
            </div><br>
            <div>
              <button style="font-size: 20px;" id="createPDFFile" onclick="createHanzi()">生成笔顺</button>
            </div>


            <div><iframe id="pdf" style="width:100%; height: 80%; display: none;"></iframe></div>
        </div>
    </div>
  </body>

  <script>

const { degrees,PDFDocument, StandardFonts, rgb, popGraphicsState, pushGraphicsState, scale, translate,} = PDFLib

async function createHanzi() {

  const word =document.getElementById('text-input').value;
  let words = "";
  var re= RegExp("^[A-Za-z0-9]+$");
  var re1=RegExp("^[\u4E00-\u9FA5A-Za-z0-9]+$");
  for (let char of word){
    if (re.test(char) || !re1.test(char)){
    }
    else{
      words = words + char;
    }
  }
  if(words ==""){
    alert("没有输入任何汉字");
  }
  else{
    const pdfDoc = await PDFLib.PDFDocument.create();
    const page = pdfDoc.addPage([297, 210]);
    const color = rgb(0, 0, 0);
    const dashArray = [1, 0.5];
    const opacity = 0.75;
    const gridthickness = 0.1;
    const strokethickness = 6;
    page.pushOperators(
    pushGraphicsState(),
    scale(1, -1),
    translate(0, -210),
    );

    let startx = 12;
    let starty = 10;
    let size = 14;
    let charNum = 12;
    if(words.length < 12){
      charNum = words.length;
      starty = (210-14*words.length-2*(words.length-1))/2;
    }

    for (let i=0; i<charNum;i++){
      for (let j=0; j<19; j++){
        let y = starty + i*16;
        let x = startx;
        if(j > 0){
          x = startx + 7 + j*14;
        }

        page.drawLine({start: { x: x, y: y },end: { x: x+size, y: y},thickness: gridthickness,color:color, opacity: opacity,});
        page.drawLine({start: { x: x, y: y },end: { x: x, y: y+size},thickness: gridthickness,color:color, opacity: opacity,});
        page.drawLine({start: { x: x, y: y },end: { x: x+size, y: y+size},thickness: gridthickness,color:color, dashArray: dashArray,opacity: opacity,});
        page.drawLine({start: { x: x+size, y: y+size },end: { x: x, y: y+size},thickness: gridthickness,color:color, opacity: opacity,});
        page.drawLine({start: { x: x+size, y: y+size },end: { x: x+size, y: y},thickness: gridthickness,color:color, opacity: opacity,});
        page.drawLine({start: { x: x+size, y: y },end: { x: x, y: y+size},thickness: gridthickness,color:color, dashArray: dashArray,opacity: opacity,});
        page.drawLine({start: { x: x+size/2, y: y },end: { x: x+size/2, y: y+size},thickness: gridthickness,color:color, dashArray: dashArray,opacity: opacity,});
        page.drawLine({start: { x: x, y: y+size/2 },end: { x: x+size, y: y+size/2},thickness: gridthickness,color:color, dashArray: dashArray,opacity: opacity,});

//        const charData = await fetch("assets/hanzi/"+words[i]+".json")    //////////////////cnxkncjkxncjk
        const charData = await fetch("/gethanzi?char="+words[i])
        .then(res => res.json());

        if (j==0){
          var strokes = charData.strokes.slice(0, charData.strokes.length + 1);
          strokes.forEach(function(stroke){
          page.drawSvgPath(stroke,{x:x,y:y+ 90*size/100,scale:0.1*size/100, rotate: degrees(0),borderColor: color, color:color,borderWidth:strokethickness});
          })
        }
        else if (j<=charData.strokes.length) {
          var strokes = charData.strokes.slice(0, j);
          var k = 0;
          strokes.forEach(function(stroke){
            k++;
            if (k==strokes.length){
              page.drawSvgPath(stroke,{x:x,y:y+ 90*size/100,scale:0.1*size/100, rotate: degrees(0),borderColor: color, color:color,borderWidth:strokethickness});
            }
            else{
              page.drawSvgPath(stroke,{x:x,y:y+ 90*size/100,scale:0.1*size/100, rotate: degrees(0),borderColor: color,borderWidth:strokethickness});
            }
          });
        }
        else {
          var strokes = charData.strokes.slice(0, charData.strokes.length + 1);
          strokes.forEach(function(stroke){
          page.drawSvgPath(stroke,{x:x,y:y+ 90*size/100,scale:0.1*size/100, rotate: degrees(0),borderColor: color,borderWidth:strokethickness});
          })
        }
      }
    }
    page.pushOperators(popGraphicsState());
    const pdfDataUri = await pdfDoc.saveAsBase64({ dataUri: true });
    document.getElementById('pdf').src = pdfDataUri;
    document.getElementById('pdf').style.display = "";  
  }
}

</script>
</html>